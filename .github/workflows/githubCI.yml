name: CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - nonprod
          - prod
      destroy:
        description: 'Destroy resources?'
        required: true
        default: false
        type: boolean
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  TERRAFORM_DIR: ./terraform
  HELM_CHART_DIR: ./helm
  APP_DIR: ./hello_app
  K8S_DIR: ./k8s

jobs:
  # ===============================
  # Stage 1️⃣: Infra (Terraform)
  # ===============================
  infra:
    name: Provision Infrastructure
    runs-on: ubuntu-latest

    outputs:
      EKS_CLUSTER: ${{ steps.set-eks-cluster.outputs.EKS_CLUSTER }}
      ECR_REPO: ${{ steps.set-ecr.outputs.ECR_REPO }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.7
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform init -input=false

    - name: Terraform Apply
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform apply -auto-approve

    - name: Set ECR repo URL
      id: set-ecr
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        ECR_REPO=$(terraform output -raw repository_url | tr -d '\n')
        echo "ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
        echo "::set-output name=ECR_REPO::$ECR_REPO"
    - name: Set EKS Cluster name
      id: set-eks-cluster
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        EKS_CLUSTER=$(terraform output -raw eks_cluster_name | tr -d '\n')
        echo "EKS_CLUSTER=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "::set-output name=EKS_CLUSTER::$EKS_CLUSTER"
############
    - name: Get Terraform NLB outputs
      id: tf_outputs
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        NLB_ARN=$(terraform output -raw nlb_arn)
        NLB_DNS=$(terraform output -raw nlb_dns_name)
        echo "NLB_ARN=$NLB_ARN" >> $GITHUB_ENV
        echo "NLB_DNS=$NLB_DNS" >> $GITHUB_ENV
        echo "::set-output name=NLB_ARN::$NLB_ARN"
        echo "::set-output name=NLB_DNS::$NLB_DNS"
###########3


  # ==================================
  # Stage 2️⃣: Platform Tools (Helm)
  # ==================================
  platform-tools:
    name: Install Platform Tools
    needs: infra
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}


    # Install kubectl
    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
    # Install Helm
    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    # Update kubeconfig
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}
    # Install ingress-nginx controller
    - name: Install ingress-nginx controller
      run: |
        if kubectl get ns ingress-nginx >/dev/null 2>&1; then
          echo "ingress-nginx already exists"
        else
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-type"="nlb" \
            --set controller.service.annotations."service\.beta\.kubernetes\.io/aws-load-balancer-target-group-arn"="${{ needs.infra.outputs.NLB_ARN }}"
          kubectl rollout status deployment/ingress-nginx-controller \
            -n ingress-nginx --timeout=120s
        fi
    - name: Install Argo CD
      run: |
        set -e
        if kubectl get ns argocd >/dev/null 2>&1; then
          echo "Argo CD already installed"
        else
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade --install argocd argo/argo-cd \
            --namespace argocd \
            --create-namespace \
            --set server.service.type=ClusterIP \
            --set server.ingress.enabled=true \
            --set server.ingress.ingressClassName=nginx
        fi
    - name: Verify platform tools
      run: |
        kubectl get pods -n ingress-nginx
        kubectl get pods -n argocd
        kubectl get svc -n argocd
  # ==================================
  # Stage 3️⃣: Application Deploy
  # ==================================
  deploy:
    name: Build & Deploy Application
    needs: [infra, platform-tools]
    runs-on: ubuntu-latest

    steps:    
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}
        kubectl get nodes
    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    # =========================
    # Docker Build & Push
    # =========================
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} \
        | docker login --username AWS \
          --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
    - name: Build Docker Image
      working-directory: ${{ env.APP_DIR }}
      run: |
        docker build -t ${{ needs.infra.outputs.ECR_REPO }}:latest .
    - name: Push Docker Image
      run: |
        docker push ${{ needs.infra.outputs.ECR_REPO }}:latest
    # =========================
    # Helm Deploy
    # =========================
    - name: Deploy Helm chart
      run: |
        helm upgrade --install hello-app ${{ env.HELM_CHART_DIR }} \
          --set image.repository=${{ needs.infra.outputs.ECR_REPO }} \
          --set image.tag=latest
    - name: Verify Deployment
      run: |
        kubectl get pods
        kubectl get svc
#########
# access the app
    - name: Apply Ingress
      run: |
        kubectl apply -f ${{ env.K8S_DIR }}/hello-ingress.yaml
    - name: Wait for Ingress to be ready
      run: |
        kubectl wait --namespace ingress-nginx \
          --for=condition=available deployment/ingress-nginx-controller \
          --timeout=180s
    - name: Wait and Get Application URL
      run: |
        echo "Waiting for Application LoadBalancer..."
        for i in {1..30}; do
          HOSTNAME=$(kubectl get ingress hello-app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$HOSTNAME" ]; then
            echo "Application URL:"
            echo "http://$HOSTNAME"
            exit 0
          fi
          echo "Still waiting..."
          sleep 10
        done
        echo "Ingress LoadBalancer not ready after waiting"
        exit 1