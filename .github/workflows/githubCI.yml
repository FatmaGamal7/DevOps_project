name: CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - nonprod
          - prod
      destroy:
        description: 'Destroy resources?'
        required: true
        default: false
        type: boolean
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  TERRAFORM_DIR: ./terraform
  HELM_CHART_DIR: ./helm
  APP_DIR: ./hello_app
  K8S_DIR: ./k8s

jobs:
  # ===============================
  # Stage 1️⃣: Infra (Terraform)
  # ===============================
  infra:
    name: Provision Infrastructure
    runs-on: ubuntu-latest

    outputs:
      EKS_CLUSTER: ${{ steps.set-eks-cluster.outputs.EKS_CLUSTER }}
      ECR_REPO: ${{ steps.set-ecr.outputs.ECR_REPO }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.7
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform init -input=false

    - name: Terraform Apply
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform apply -auto-approve

    - name: Set ECR repo URL
      id: set-ecr
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        ECR_REPO=$(terraform output -raw repository_url | tr -d '\n')
        echo "ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
        echo "::set-output name=ECR_REPO::$ECR_REPO"
    - name: Set EKS Cluster name
      id: set-eks-cluster
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        EKS_CLUSTER=$(terraform output -raw eks_cluster_name | tr -d '\n')
        echo "EKS_CLUSTER=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "::set-output name=EKS_CLUSTER::$EKS_CLUSTER"
  # ==================================
  # Stage 2️⃣: Platform Tools (Helm)
  # ==================================
  platform-tools:
    name: Install Platform Tools
    needs: infra
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}


    # Install kubectl
    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
    # Install Helm
    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    # Update kubeconfig
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}
    # Install ingress-nginx controller
    - name: Install ingress-nginx controller
      run: |
        if kubectl get ns ingress-nginx >/dev/null 2>&1; then
          echo "ingress-nginx already exists"
        else
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace
          kubectl rollout status deployment/ingress-nginx-controller \
            -n ingress-nginx --timeout=120s
        fi
    - name: Install Argo CD
      run: |
        set -e
        if kubectl get ns argocd >/dev/null 2>&1; then
          echo "Argo CD already installed"
        else
          helm repo add argo https://argoproj.github.io/argo-helm
          helm repo update
          helm upgrade --install argocd argo/argo-cd \
            --namespace argocd \
            --create-namespace \
            --set server.service.type=ClusterIP \
            --set server.ingress.enabled=true \
            --set server.ingress.ingressClassName=nginx
        fi

    - name: Verify platform tools
      run: |
        kubectl get pods -n ingress-nginx
        kubectl get pods -n argocd
        kubectl get svc -n argocd
  # ==================================
  # Stage 3️⃣: Application Deploy
  # ==================================
  deploy:
    name: Build & Deploy Application
    needs: [infra, platform-tools]
    runs-on: ubuntu-latest

    steps:    
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}
        kubectl get nodes
    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
    # =========================
    # Docker Build & Push
    # =========================
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} \
        | docker login --username AWS \
          --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
    - name: Build Docker Image
      working-directory: ${{ env.APP_DIR }}
      run: |
        docker build -t ${{ needs.infra.outputs.ECR_REPO }}:latest .
    - name: Push Docker Image
      run: |
        docker push ${{ needs.infra.outputs.ECR_REPO }}:latest

    # =========================
    # Helm Deploy
    # =========================
    - name: Deploy Helm chart
      run: |
        helm upgrade --install hello-app ${{ env.HELM_CHART_DIR }} \
          --set image.repository=${{ needs.infra.outputs.ECR_REPO }} \
          --set image.tag=latest

    - name: Verify Deployment
      run: |
        kubectl get pods
        kubectl get svc
#########
# access the app
    - name: Apply Ingress
      run: |
        kubectl delete ingress hello-app --ignore-not-found
        kubectl apply -f ${{ env.K8S_DIR }}/hello-ingress.yaml

    - name: Wait for Ingress to be ready
      run: |
        kubectl wait --namespace ingress-nginx \
          --for=condition=available deployment/ingress-nginx-controller \
          --timeout=180s

    - name: Wait and Get Application URL
      run: |
        echo "Waiting for Application LoadBalancer..."
        for i in {1..30}; do
          HOSTNAME=$(kubectl get ingress hello-app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$HOSTNAME" ]; then
            echo "Application URL:"
            echo "http://$HOSTNAME"
            exit 0
          fi
          echo "Still waiting..."
          sleep 10
        done
        echo "Ingress LoadBalancer not ready after waiting"
        exit 1


  # =========================
  # Stage 4️⃣: Continuous Deployment (CD)
  # =========================
  cd:
    name: Continuous Deployment via Argo CD
    runs-on: ubuntu-latest
    needs: [infra, deploy]
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GIT_TOKEN }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}

      - name: Apply Argo CD Application
        run: |
          kubectl apply -f k8s/hello-app-argocd.yaml -n argocd


# =========================
# Stage 5️⃣: SonarQube Deploy & Scan
# =========================
  sonar:
    name: Deploy & Run SonarQube Scan
    runs-on: ubuntu-latest
    needs: deploy
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure kubectl
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}

      - name: Install Helm
        run: |
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Deploy SonarQube via Helm
        run: |
          helm upgrade --install sonarqube ./helm-platform/sonarqube \
            --namespace sonarqube --create-namespace

      - name: Wait for SonarQube LoadBalancer
        run: |
          echo "Waiting for SonarQube LoadBalancer..."
          for i in {1..30}; do
            SONAR_URL=$(kubectl get svc sonarqube -n sonarqube -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
            if [ -n "$SONAR_URL" ]; then
              echo "SONAR_URL=http://$SONAR_URL:9000" >> $GITHUB_ENV
              break
            fi
            echo "Still waiting..."
            sleep 10
          done

      - name: Install SonarScanner
        run: |
          curl -Lo sonar-scanner.zip https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.9.2.731.zip
          unzip sonar-scanner.zip
          export PATH=$PWD/sonar-scanner-4.9.2.731/bin:$PATH

      - name: Run SonarQube Analysis
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
        run: |
          sonar-scanner \
            -Dsonar.projectKey=hello-app \
            -Dsonar.sources=. \
            -Dsonar.host.url=$SONAR_URL \
            -Dsonar.login=$SONAR_TOKEN
