name: CI/CD Pipeline

on:
  workflow_dispatch:
    inputs:
      env:
        description: 'Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - nonprod
          - prod
      destroy:
        description: 'Destroy resources?'
        required: true
        default: false
        type: boolean
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

env:
  AWS_REGION: us-east-1
  TERRAFORM_DIR: ./terraform
  HELM_CHART_DIR: ./helm
  APP_DIR: ./hello_app
  K8S_DIR: ./k8s

jobs:
  # ===============================
  # Stage 1️⃣: Infra (Terraform)
  # ===============================
  infra:
    name: Provision Infrastructure
    runs-on: ubuntu-latest

    outputs:
      EKS_CLUSTER: ${{ steps.set-eks-cluster.outputs.EKS_CLUSTER }}
      ECR_REPO: ${{ steps.set-ecr.outputs.ECR_REPO }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.5.7
        terraform_wrapper: false

    - name: Terraform Init
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform init -input=false

    - name: Terraform Apply
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: terraform apply -auto-approve

    - name: Set ECR repo URL
      id: set-ecr
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        ECR_REPO=$(terraform output -raw repository_url | tr -d '\n')
        echo "ECR_REPO=$ECR_REPO" >> $GITHUB_ENV
        echo "::set-output name=ECR_REPO::$ECR_REPO"

    - name: Set EKS Cluster name
      id: set-eks-cluster
      working-directory: ${{ env.TERRAFORM_DIR }}
      run: |
        EKS_CLUSTER=$(terraform output -raw eks_cluster_name | tr -d '\n')
        echo "EKS_CLUSTER=$EKS_CLUSTER" >> $GITHUB_ENV
        echo "::set-output name=EKS_CLUSTER::$EKS_CLUSTER"

  # ==================================
  # Stage 2️⃣: Platform Tools (Helm)
  # ==================================
  platform-tools:
    name: Install Platform Tools
    needs: infra
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}

    - name: Install ingress-nginx controller
      run: |
        if kubectl get ns ingress-nginx >/dev/null 2>&1; then
          echo "ingress-nginx already exists"
        else
          helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
          helm repo update
          helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
            --namespace ingress-nginx --create-namespace
          kubectl rollout status deployment/ingress-nginx-controller \
            -n ingress-nginx --timeout=120s
        fi

    # - name: Install Argo CD
    #   run: |
    #     set -euo pipefail
    #     helm upgrade --install argocd argo/argo-cd \
    #       --namespace argocd \
    #       --create-namespace \
    #       --wait \
    #       --timeout 10m \
    #       --set server.service.type=ClusterIP \
    #       --set server.ingress.enabled=true \
    #       --set server.ingress.ingressClassName=nginx
    #     kubectl get pods -n argocd


    - name: Verify platform tools
      run: |
        kubectl get pods -n ingress-nginx
    #      kubectl get pods -n argocd
    #     kubectl get svc -n argocd

  # ==================================
  # Stage 3️⃣: Application Deploy
  # ==================================
  deploy:
    name: Build & Deploy Application
    needs: [infra, platform-tools]
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ needs.infra.outputs.EKS_CLUSTER }}
        kubectl get nodes

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    # =========================
    # Docker Build & Push
    # =========================
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} \
        | docker login --username AWS \
          --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

    - name: Build Docker Image
      working-directory: ${{ env.APP_DIR }}
      run: |
        docker build -t ${{ needs.infra.outputs.ECR_REPO }}:latest .

    - name: Push Docker Image
      run: |
        docker push ${{ needs.infra.outputs.ECR_REPO }}:latest

    # =========================
    # Helm Deploy
    # =========================
    - name: Deploy Helm chart
      run: |
        helm upgrade --install my-app ${{ env.HELM_CHART_DIR }} \
          --set image.repository=${{ needs.infra.outputs.ECR_REPO }} \
          --set image.tag=latest

    - name: Verify Deployment
      run: |
        kubectl get pods
        kubectl get svc





# ######################################
# name: CI-CD Terraform & Kubernetes

# on:
#   workflow_dispatch:
#     inputs:
#       env:
#         description: 'Environment'
#         required: true
#         default: 'prod'
#         type: choice
#         options:
#           - nonprod
#           - prod
#       destroy:
#         description: 'Destroy resources?'
#         required: true
#         default: false
#         type: boolean

# env:
#   TF_DIR: terraform
#   AWS_REGION: eu-west-1

# jobs:

#   deploy:
#     if: ${{ github.event.inputs.destroy == 'false' }}
#     runs-on: ubuntu-latest

#     steps:
#       - uses: actions/checkout@v4

#       # ✅ Configure AWS once globally
#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Install Terraform
#         uses: hashicorp/setup-terraform@v2
#         with:
#          terraform_wrapper: false
#       - name: Install kubectl
#         uses: azure/setup-kubectl@v3

#       - name: Install Helm
#         uses: azure/setup-helm@v3

#       # =========================
#       # Terraform Plan + Apply
#       # =========================
#       - name: Terraform Init
#         run: |
#           cd $TF_DIR
#           terraform init -input=false

#       - name: Terraform Workspace
#         run: |
#           cd $TF_DIR
#           terraform workspace select ${{ github.event.inputs.env }} || \
#           terraform workspace new ${{ github.event.inputs.env }}

#       - name: Terraform Apply
#         run: |
#           cd $TF_DIR
#           terraform apply \
#             -var-file="${{ github.event.inputs.env }}.tfvars" \
#             -auto-approve

#       # =========================
#       # Kubernetes Config
#       # =========================
#       - name: Configure kubeconfig
#         run: |
#           set -euo pipefail
#           cd $TF_DIR

#           terraform init -input=false
#           terraform workspace select ${{ github.event.inputs.env }}

#           CLUSTER_NAME=$(terraform output -raw cluster_name | tr -d '\n' | xargs)


#           echo "Cluster name is: $CLUSTER_NAME"

#           aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"
#           kubectl get nodes


#       # =========================
#       # Install Ingress
#       # =========================
#       - name: Install Ingress Nginx
#         run: |
#           helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
#           helm repo update
#           helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \
#             --namespace ingress-nginx \
#             --create-namespace \
#             --set controller.service.type=LoadBalancer \
#             --wait --timeout 5m

#       # =========================
#       # Build & Push Docker
#       # =========================
#       - name: Build & Push Docker Image
#         run: |
#           cd $TF_DIR
#           ECR_URL=$(terraform output -raw ecr_repository_url)
#           cd ..

#           IMAGE_TAG=${GITHUB_RUN_ID}
#           ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)

#           aws ecr get-login-password --region $AWS_REGION | \
#           docker login --username AWS --password-stdin \
#           $ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com

#           docker build -t app:$IMAGE_TAG app
#           docker tag app:$IMAGE_TAG $ECR_URL:$IMAGE_TAG
#           docker push $ECR_URL:$IMAGE_TAG

#       # =========================
#       # Helm Deploy App
#       # =========================
#       - name: Deploy App via Helm
#         run: |
#           cd $TF_DIR
#           ECR_URL=$(terraform output -raw ecr_repository_url)
#           CLUSTER_NAME=$(terraform output -raw cluster_name)
#           cd ..

#           IMAGE_TAG=${GITHUB_RUN_ID}

#           aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"

#           helm upgrade --install auto-dev-demo helm/auto-dev-demo \
#             --namespace demo \
#             --create-namespace \
#             --set image.repository=$ECR_URL \
#             --set image.tag=$IMAGE_TAG \
#             --wait

#           kubectl get pods -n demo
#           kubectl get ingress -n demo


#   destroy:
#     if: ${{ github.event.inputs.destroy == 'true' }}
#     runs-on: ubuntu-latest

#     steps:
#       - uses: actions/checkout@v4

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ env.AWS_REGION }}

#       - name: Install Terraform
#         uses: hashicorp/setup-terraform@v2

#       - name: Terraform Destroy
#         run: |
#           cd $TF_DIR
#           terraform init -input=false
#           terraform workspace select ${{ github.event.inputs.env }}
#           terraform destroy \
#             -var-file="${{ github.event.inputs.env }}.tfvars" \
#             -auto-approve