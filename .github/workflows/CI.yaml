name: CI
on:
  workflow_call:
    inputs:
      eks_cluster:
        required: true
        type: string
      ecr_repo:
        required: true
        type: string

env:
  AWS_REGION: us-east-1
  HELM_CHART_DIR: ./helm
  APP_DIR: ./hello_app
  K8S_DIR: ./k8s

jobs:
  deploy:
    name: Build & Deploy Application
    runs-on: ubuntu-latest

    steps:    
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Install kubectl
      run: |
        K8S_VERSION=$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt | tr -d '\n')
        curl -LO https://storage.googleapis.com/kubernetes-release/release/${K8S_VERSION}/bin/linux/amd64/kubectl
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ inputs.eks_cluster }}
        kubectl get nodes

    - name: Install Helm
      run: |
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

    # =========================
    # Docker Build & Push
    # =========================
    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region ${{ env.AWS_REGION }} \
        | docker login --username AWS \
          --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com

    - name: Build Docker Image
      working-directory: ${{ env.APP_DIR }}
      run: |
        docker build -t ${{ inputs.ecr_repo }}:latest .

    - name: Push Docker Image
      run: |
        docker push ${{ inputs.ecr_repo }}:latest

    # =========================
    # Helm Deploy
    # =========================
    - name: Deploy Helm chart
      run: |
        helm upgrade --install hello-app ${{ env.HELM_CHART_DIR }} \
          --set image.repository=${{ inputs.ecr_repo }} \
          --set image.tag=latest

    - name: Verify Deployment
      run: |
        kubectl get pods
        kubectl get svc

    # =========================
    # Access the App (Ingress)
    # =========================
    - name: Apply Ingress
      run: |
        kubectl delete ingress hello-app --ignore-not-found
        kubectl apply -f ${{ env.K8S_DIR }}/hello-ingress.yaml

    - name: Wait for Ingress to be ready
      run: |
        kubectl wait --namespace ingress-nginx \
          --for=condition=available deployment/ingress-nginx-controller \
          --timeout=180s

    - name: Wait and Get Application URL
      run: |
        echo "Waiting for Application LoadBalancer..."
        for i in {1..30}; do
          HOSTNAME=$(kubectl get ingress hello-app-ingress -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$HOSTNAME" ]; then
            echo "Application URL: http://$HOSTNAME"
            echo "APP_URL=http://$HOSTNAME" >> $GITHUB_ENV
            exit 0
          fi
          echo "Still waiting..."
          sleep 10
        done
        echo "Ingress LoadBalancer not ready after waiting"
        exit 1

    # =========================
    # SonarQube Scan
    # =========================
    - name: Get SonarQube URL
      id: sonar-url
      run: |
        SONAR_HOST=$(kubectl get svc sonarqube-sonarqube -n sonarqube -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
        echo "SONAR_HOST_URL=http://$SONAR_HOST:9000" >> $GITHUB_ENV

    - name: SonarQube Scan
      uses: sonarsource/sonarqube-scan-action@master
      env:
        SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
        SONAR_HOST_URL: ${{ env.SONAR_HOST_URL }}
      with:
        args: >
          -Dsonar.projectKey=hello-app
          -Dsonar.projectName=hello-app
          -Dsonar.sources=.
          -Dsonar.qualitygate.wait=true

    - name: Check Quality Gate
      run: |
        echo "SonarQube analysis is finished and project created automatically!"